{
  "AtCoder Template": {
    "prefix": "atc",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#include <atcoder/all>",
      "",
      "using namespace std;",
      "using namespace atcoder;",
      "typedef long long ll;",
      "template <class T, class... Ts>",
      "void println(const T& a, const Ts&... b) {",
      "    cout << a;",
      "    (void)(cout << ... << (cout << ' ', b));",
      "    cout << '\\n';",
      "}",
      "template <class T>",
      "void printv(const T& a, string sep = \" \", string end = \"\\n\") {",
      "    for (auto x : a) {",
      "        (void)(cout << x << sep);",
      "    }",
      "    cout << end;",
      "}",
      "void println() { cout << '\\n'; }",
      "template <class T, class... Ts>",
      "void eprintln(const T& a, const Ts&... b) {",
      "    cerr << a;",
      "    (void)(cerr << ... << (cerr << ' ', b));",
      "    cerr << '\\n';",
      "}",
      "template <class T>",
      "void eprintv(const T& a, string sep = \" \", string end = \"\\n\") {",
      "    for (auto x : a) {",
      "        (void)(cerr << x << sep);",
      "    }",
      "    cerr << end;",
      "}",
      "void eprintln() { cerr << '\\n'; }",
      "template <class... T>",
      "void input(T&... a) { (cin >> ... >> a); }",
      "#define rep(i, n) for (ll i = 0; i < n; i++)",
      "#define rep1(i, n) for (ll i = 1; i <= n; i++)",
      "#define yesno(a) cout << (a ? \"Yes\" : \"No\") << '\\n';",
      "#define YESNO(a) cout << (a ? \"YES\" : \"NO\") << '\\n';",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "    cout.tie(nullptr);",
      "    cout << fixed << setprecision(15);",
      "    ",
      "    $0",
      "    ",
      "    return 0;",
      "}"
    ],
    "description": "AtCoder Template"
  },
  "BFS": {
    "prefix": "bfs",
    "body": [
      "queue<int> q;",
      "q.push(s);",
      "vector<int> dist(n, -1);",
      "dist[s] = 0;",
      "while (!q.empty()) {",
      "  int v = q.front();",
      "  q.pop();",
      "  for (auto nv : g[v]) {",
      "    if (dist[nv] != -1) continue;",
      "    dist[nv] = dist[v] + 1;",
      "    q.push(nv);",
      "  }",
      "}"
    ],
    "description": "BFS"
  },
  "DFS": {
    "prefix": "dfs",
    "body": [
      "vector<int> dist(n, -1);",
      "dist[s] = 0;",
      "function<void(int)> dfs = [&](int v) {",
      "  for (auto nv : g[v]) {",
      "    if (dist[nv] != -1) continue;",
      "    dist[nv] = dist[v] + 1;",
      "    dfs(nv);",
      "  }",
      "};",
      "dfs(s);"
    ],
    "description": "DFS"
  },
  "UnionFind": {
    "prefix": "unionfind",
    "body": [
      "struct UnionFind {",
      "  vector<int> par;",
      "  vector<int> siz;",
      "  UnionFind(int n) : par(n), siz(n, 1) {",
      "    rep(i, n) par[i] = i;",
      "  }",
      "  int root(int x) {",
      "    if (par[x] == x) return x;",
      "    return par[x] = root(par[x]);",
      "  }",
      "  bool same(int x, int y) { return root(x) == root(y); }",
      "  void unite(int x, int y) {",
      "    x = root(x);",
      "    y = root(y);",
      "    if (x == y) return;",
      "    if (siz[x] < siz[y]) swap(x, y);",
      "    par[y] = x;",
      "    siz[x] += siz[y];",
      "  }",
      "  int size(int x) { return siz[root(x)]; }",
      "};"
    ],
    "description": "UnionFind"
  },
  "LRUD": {
    "prefix": "lrud",
    "body": [
      "const map<char, pair<ll, ll>> d = {",
      "  {'L', {0, -1}},",
      "  {'R', {0, 1}},",
      "  {'U', {-1, 0}},",
      "  {'D', {1, 0}},",
      "};"
    ],
    "description": "LRUD"
  },
  "rng": {
    "prefix": "rng",
    "body": [
      "unsigned long rng(){",
      "  static unsigned long x=88172645463325252UL;",
      "  x^=x<<7;",
      "  x^=x>>9;",
      "  return x;",
      "}"
    ],
    "description": "rng"
  }
}
