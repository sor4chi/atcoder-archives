{
  "AtCoder Template": {
    "prefix": "atc",
    "body": [
      "#include <bits/stdc++.h>",
      "",
      "#include <atcoder/all>",
      "",
      "using namespace std;",
      "using namespace atcoder;",
      "typedef long long ll;",
      "template <class T, class... Ts>",
      "void print(const T& a, const Ts&... b) {",
      "    cout << a;",
      "    (void)(cout << ... << (cout << ' ', b));",
      "    cout << '\\n';",
      "}",
      "template <class... T>",
      "void input(T&... a) { (cin >> ... >> a); }",
      "void print() { cout << '\\n'; }",
      "#define rep(i, n) for (ll i = 0; i < n; i++)",
      "",
      "int main() {",
      "    ios::sync_with_stdio(false);",
      "    cin.tie(nullptr);",
      "    cout.tie(nullptr);",
      "    cout << fixed << setprecision(15);",
      "    ",
      "    $0",
      "    ",
      "    return 0;",
      "}"
    ],
    "description": "AtCoder Template"
  },
  "BFS": {
    "prefix": "bfs",
    "body": [
      "queue<int> q;",
      "q.push(s);",
      "vector<int> dist(n, -1);",
      "dist[s] = 0;",
      "while (!q.empty()) {",
      "  int v = q.front();",
      "  q.pop();",
      "  for (auto nv : g[v]) {",
      "    if (dist[nv] != -1) continue;",
      "    dist[nv] = dist[v] + 1;",
      "    q.push(nv);",
      "  }",
      "}"
    ],
    "description": "BFS"
  },
  "DFS": {
    "prefix": "dfs",
    "body": [
      "vector<int> dist(n, -1);",
      "dist[s] = 0;",
      "function<void(int)> dfs = [&](int v) {",
      "  for (auto nv : g[v]) {",
      "    if (dist[nv] != -1) continue;",
      "    dist[nv] = dist[v] + 1;",
      "    dfs(nv);",
      "  }",
      "};",
      "dfs(s);"
    ],
    "description": "DFS"
  },
  "UnionFind": {
    "prefix": "unionfind",
    "body": [
      "struct UnionFind {",
      "  vector<int> par;",
      "  vector<int> siz;",
      "  UnionFind(int n) : par(n), siz(n, 1) {",
      "    rep(i, n) par[i] = i;",
      "  }",
      "  int root(int x) {",
      "    if (par[x] == x) return x;",
      "    return par[x] = root(par[x]);",
      "  }",
      "  bool same(int x, int y) { return root(x) == root(y); }",
      "  void unite(int x, int y) {",
      "    x = root(x);",
      "    y = root(y);",
      "    if (x == y) return;",
      "    if (siz[x] < siz[y]) swap(x, y);",
      "    par[y] = x;",
      "    siz[x] += siz[y];",
      "  }",
      "  int size(int x) { return siz[root(x)]; }",
      "};"
    ],
    "description": "UnionFind"
  }
}
